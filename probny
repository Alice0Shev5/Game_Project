
from constans import pygame, screen_height, screen_width, FPS
from all_windows import map1
back = pygame.image.load('data/bg.jpg')


# класс для мага
class Magician(pygame.sprite.Sprite):
    # Изначально маг смотрит вправо, поэтому right = True
    right = True

    def __init__(self):

        super().__init__()

        # Создание изображения для игрока(находится в папке data)

        self.image = pygame.image.load('data/idle.png')

        self.rect = self.image.get_rect()

        # Задаем вектор скорости игрока
        self.change_x = 0
        self.change_y = 0

    # функция для передвижения мага

    def update(self):
        #  устанавливаем для мага гравитацию
        self.count_gravitation()

        # Передвигаем мага  вправо/влево
        # change_x будет меняться позже при нажатии на стрелочки клавиатуры
        self.rect.x += self.change_x

        # проверка на столкновение с платформами
        block_hit_list = pygame.sprite.spritecollide(self, self.level.platform_list, False)
        block_hit_list1 = pygame.sprite.spritecollide(self, self.level.fire, False)
        # block_hit_list2 = pygame.sprite.collide_rect(self, flower)

        # print(block_hit_list2)

        # Перебираем все возможные объекты, с которыми могли бы столкнуться
        for block in block_hit_list:
            # Если мы идем направо,
            # устанавливает нашу правую сторону на левой стороне предмета, которого мы ударили
            if self.change_x > 0:
                self.rect.right = block.rect.left
            elif self.change_x < 0:
                # В противном случае, если мы движемся влево, то делаем наоборот
                self.rect.left = block.rect.right

        # передвижение вверх/вниз
        self.rect.y += self.change_y

        # делаем то же самое, только для вверх вниз
        block_hit_list = pygame.sprite.spritecollide(self, self.level.platform_list, False)
        for block in block_hit_list:
            # Устанавливаем нашу позицию на основе верхней / нижней части объекта, на который мы попали
            if self.change_y > 0:
                self.rect.bottom = block.rect.top
            elif self.change_y < 0:
                self.rect.top = block.rect.bottom

            # Останавливаем вертикальное движение
            self.change_y = 0

    # функция для вычисления гравитации при падении мага

    def count_gravitation(self):
        if self.change_y == 0:
            self.change_y = 1
        else:
            self.change_y += .95

        # если маг на земле, то устаноим позицию Y = 0
        if self.rect.y >= screen_height - self.rect.height and self.change_y >= 0:
            self.change_y = 0
            self.rect.y = screen_height - self.rect.height

    def jump(self):
        # Обработка прыжка
        #  нужно проверять здесь, контактируем ли мы с чем-либо
        # или другими словами, не находимся ли мы в полете.
        # Для этого опускаемся на 10 единиц, проверем соприкосновение и далее поднимаемся обратно
        self.rect.y += 10
        platform_hit_list = pygame.sprite.spritecollide(self, self.level.platform_list, False)
        self.rect.y -= 10

        # Если все в порядке, прыгаем вверх
        if len(platform_hit_list) > 0 or self.rect.bottom >= screen_height:
            self.change_y = -16

    # Передвижение игрока
    def go_left(self):
        # Сами функции будут вызваны позже из основного цикла
        self.change_x = -9  # Двигаем игрока по Х
        if self.right:  # Проверяем куда он смотрит и если что, то переворачиваем его
            self.flip()
            self.right = False

    def go_right(self):
        # то же самое, но вправо
        self.change_x = 9
        if not self.right:
            self.flip()
            self.right = True

    def stop(self):
        # вызываем этот метод, когда не нажимаем на клавиши
        self.change_x = 0

    def flip(self):
        # переворот игрока (зеркальное отражение)
        self.image = pygame.transform.flip(self.image, True, False)


# Класс для  платформ
class Platform(pygame.sprite.Sprite):
    def __init__(self, width, height):
        # Конструктор платформ
        super().__init__()

        self.image = pygame.image.load('data/platform.png')

        self.rect = self.image.get_rect()


class Fire(pygame.sprite.Sprite):
    def __init__(self, width, height):
        super().__init__()

        self.image = pygame.image.load('data/fire.png')

        self.rect = self.image.get_rect()


# Класс для расстановки платформ на уровне
class Level01(object):
    def __init__(self, player):
        self.platform_list = pygame.sprite.Group()
        self.fire = pygame.sprite.Group()

        self.player = player

    # обновление чтобы рисовались платформы
    def update(self):
        self.platform_list.update()
        self.fire.update()

    # функция для рисования объектов на уровне
    def draw(self, screen):
        # Рисуем задний фон
        screen.blit(back, (0, 0))

        # Рисуем все платформы из группы спрайтов
        self.platform_list.draw(screen)
        self.fire.draw(screen)


class Level_1(Level01):
    def __init__(self, player):
        # Вызываем родительский конструктор
        Level01.__init__(self, player)

        # Массив с данными про платформы. Данные в таком формате:
        # ширина, высота, x и y позиция

        # Перебираем массив и добавляем каждую платформу в группу спрайтов - platform_list

        for platform in L1:
            block = Platform(platform[0], platform[1])
            block.rect.x = platform[2]
            block.rect.y = platform[3]
            block.player = self.player
            self.platform_list.add(block)


def load_level(filename):
    filename = "data/" + filename
    # читаем уровень, убирая символы перевода строки
    with open(filename, 'r') as mapFile:
        level_map = [line.strip() for line in mapFile]

    # и подсчитываем максимальную длину
    max_width = max(map(len, level_map))

    # дополняем каждую строку пустыми клетками ('.')
    return list(map(lambda x: x.ljust(max_width, '.'), level_map))


def generate_level(level):
    level1 = []
    x1, y1 = 10, 10
    for y in range(len(level)):
        y1 += 470
        for x in range(len(level[y])):
            x1 += 50
            if level[y][x] == '.':
                pass
            elif level[y][x] == '#':
                print(x1, y1)
                level1.append([210, 32, x1, y1])
            elif level[y][x] == '@':
                level1.append([50, 50, x1, y1])
                fireman = Fire(x1, y1)
    # вернем игрока, а также размер поля в клетках
    print(level1)
    return level1


def a(level):
    x1, y1 = 10, 10
    for y in range(len(level)):
        y1 += 470
        for x in range(len(level[y])):
            x1 += 50
            if level[y][x] == '.':
                pass
            elif level[y][x] == '#':
                pass
            elif level[y][x] == '@':
                fireman = Fire(x1, y1)
    return fireman


level_map = load_level('map1.txt')
L1 = generate_level(level_map)
fireman = a(level_map)
print(L1)
print(fireman)


# Основная функция программы
def main():
    pygame.init()

    size = [screen_width, screen_height]
    screen = pygame.display.set_mode(size)

    pygame.display.set_caption("Magician")

    # Создаем мага
    player = Magician()

    # Создаем все уровни
    level_list = []
    level_list.append(Level_1(player))

    # Устанавливаем текущий уровень
    current_level_no = 0
    current_level = level_list[current_level_no]

    active_sprite_list = pygame.sprite.Group()
    player.level = current_level

    player.rect.x = 340
    player.rect.y = screen_height - player.rect.height
    fireman.rect.x = 60
    fireman.rect.y = 400

    active_sprite_list.add(player, fireman)
    running = True

    clock = pygame.time.Clock()
    while running:

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if pygame.sprite.collide_rect(player, fireman):
                map1()

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_LEFT:
                    player.go_left()
                if event.key == pygame.K_RIGHT:
                    player.go_right()
                if event.key == pygame.K_UP:
                    player.jump()

            if event.type == pygame.KEYUP:
                if event.key == pygame.K_LEFT and player.change_x < 0:
                    player.stop()
                if event.key == pygame.K_RIGHT and player.change_x > 0:
                    player.stop()
        hits = pygame.sprite.collide_rect(player, fireman)
        print(hits)

        active_sprite_list.update()

        current_level.update()

        # Если игрок приблизится к правой стороне, то дальше его не двигаем
        if player.rect.right > screen_width:
            player.rect.right = screen_width

        # Если игрок приблизится к левой стороне, то дальше его не двигаем
        if player.rect.left < 0:
            player.rect.left = 0

        # Рисуем объекты на окне
        current_level.draw(screen)
        active_sprite_list.draw(screen)

        clock.tick(FPS)

        pygame.display.flip()

    pygame.quit()


